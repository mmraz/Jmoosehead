package org.mraz.moose.dao.model.obj.moose;

import com.felees.hbnpojogen.persistence.IPojoGenEntity;
import java.io.Serializable;
import java.util.Date;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.PrimaryKeyJoinColumn;
import javax.persistence.Table;
import javax.persistence.Transient;
import org.hibernate.proxy.HibernateProxy;
import org.mraz.moose.dao.enums.subtype.moose.PlayerSubclassType;
import org.mraz.moose.dao.model.obj.moose.iface.IPlayerLasts;


/** 
 * Object mapping for hibernate-handled table: player_lasts.
 * @author autogenerated
 */

@Entity
@PrimaryKeyJoinColumn(name = "player_id")
@Table(name = "player_lasts", catalog = "moose")
public class PlayerLasts extends Player implements Cloneable, Serializable, IPojoGenEntity, IPlayerLasts {

	/** Serial Version UID. */
	private static final long serialVersionUID = -559033530L;

	

	/** Field mapping. */
	private Date attacked;
	/** Field mapping. */
	private Date attackedBy;
	/** Field mapping. */
	private Long attackedByTimer;
	/** Field mapping. */
	private Date combat;
	/** Field mapping. */
	private Date deathDt;
	/** Field mapping. */
	private Date killed;
	/** Field mapping. */
	private Date killedBy;
	/** Field mapping. */
	private Date killedDt;
	/** Field mapping. */
	private Date login;
 

	/**
 	 * Return an enum of the type of this subclass. This is useful to be able to use switch/case in your code.
 	 *
 	 * @return PlayerSubclassType enum.
 	 */
 	@Transient
 	@Override
 	public PlayerSubclassType getPlayerSubclassType() {
		return PlayerSubclassType.PLAYER_LASTS;
 	}  

 
	/** Return the type of this class. Useful for when dealing with proxies.
	* @return Defining class.
	*/
	@Override
	@Transient
	public Class<?> getClassType() {
		return PlayerLasts.class;
	}
 

    /**
     * Return the value associated with the column: attacked.
	 * @return A Date object (this.attacked)
	 */
	@Column( nullable = false  )
	public Date getAttacked() {
		return this.attacked;
		
	}
	

  
    /**  
     * Set the value related to the column: attacked.
	 * @param attacked the attacked value you wish to set
	 */
	public void setAttacked(final Date attacked) {
		this.attacked = attacked;
	}

    /**
     * Return the value associated with the column: attackedBy.
	 * @return A Date object (this.attackedBy)
	 */
	@Column( name = "attacked_by", nullable = false  )
	public Date getAttackedBy() {
		return this.attackedBy;
		
	}
	

  
    /**  
     * Set the value related to the column: attackedBy.
	 * @param attackedBy the attackedBy value you wish to set
	 */
	public void setAttackedBy(final Date attackedBy) {
		this.attackedBy = attackedBy;
	}

    /**
     * Return the value associated with the column: attackedByTimer.
	 * @return A Long object (this.attackedByTimer)
	 */
	@Column( name = "attacked_by_timer", nullable = false  )
	public Long getAttackedByTimer() {
		return this.attackedByTimer;
		
	}
	

  
    /**  
     * Set the value related to the column: attackedByTimer.
	 * @param attackedByTimer the attackedByTimer value you wish to set
	 */
	public void setAttackedByTimer(final Long attackedByTimer) {
		this.attackedByTimer = attackedByTimer;
	}

    /**
     * Return the value associated with the column: combat.
	 * @return A Date object (this.combat)
	 */
	@Column( nullable = false  )
	public Date getCombat() {
		return this.combat;
		
	}
	

  
    /**  
     * Set the value related to the column: combat.
	 * @param combat the combat value you wish to set
	 */
	public void setCombat(final Date combat) {
		this.combat = combat;
	}

    /**
     * Return the value associated with the column: deathDt.
	 * @return A Date object (this.deathDt)
	 */
	@Column( name = "death_dt"  )
	public Date getDeathDt() {
		return this.deathDt;
		
	}
	

  
    /**  
     * Set the value related to the column: deathDt.
	 * @param deathDt the deathDt value you wish to set
	 */
	public void setDeathDt(final Date deathDt) {
		this.deathDt = deathDt;
	}

    /**
     * Return the value associated with the column: killed.
	 * @return A Date object (this.killed)
	 */
	@Column( nullable = false  )
	public Date getKilled() {
		return this.killed;
		
	}
	

  
    /**  
     * Set the value related to the column: killed.
	 * @param killed the killed value you wish to set
	 */
	public void setKilled(final Date killed) {
		this.killed = killed;
	}

    /**
     * Return the value associated with the column: killedBy.
	 * @return A Date object (this.killedBy)
	 */
	@Column( name = "killed_by", nullable = false  )
	public Date getKilledBy() {
		return this.killedBy;
		
	}
	

  
    /**  
     * Set the value related to the column: killedBy.
	 * @param killedBy the killedBy value you wish to set
	 */
	public void setKilledBy(final Date killedBy) {
		this.killedBy = killedBy;
	}

    /**
     * Return the value associated with the column: killedDt.
	 * @return A Date object (this.killedDt)
	 */
	@Column( name = "killed_dt"  )
	public Date getKilledDt() {
		return this.killedDt;
		
	}
	

  
    /**  
     * Set the value related to the column: killedDt.
	 * @param killedDt the killedDt value you wish to set
	 */
	public void setKilledDt(final Date killedDt) {
		this.killedDt = killedDt;
	}

    /**
     * Return the value associated with the column: login.
	 * @return A Date object (this.login)
	 */
	@Column( nullable = false  )
	public Date getLogin() {
		return this.login;
		
	}
	

  
    /**  
     * Set the value related to the column: login.
	 * @param login the login value you wish to set
	 */
	public void setLogin(final Date login) {
		this.login = login;
	}


   /**
    * Deep copy.
	* @return cloned object
	* @throws CloneNotSupportedException on error
    */
    @Override
    public PlayerLasts clone() throws CloneNotSupportedException {
		
        final PlayerLasts copy = (PlayerLasts)super.clone();

		copy.setAttacked(this.getAttacked());
		copy.setAttackedBy(this.getAttackedBy());
		copy.setAttackedByTimer(this.getAttackedByTimer());
		copy.setCombat(this.getCombat());
		copy.setDeathDt(this.getDeathDt());
		copy.setKilled(this.getKilled());
		copy.setKilledBy(this.getKilledBy());
		copy.setKilledDt(this.getKilledDt());
		copy.setLogin(this.getLogin());
		return copy;
	}
	


	/** Provides toString implementation.
	 * @see java.lang.Object#toString()
	 * @return String representation of this class.
	 */
	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer();
		
		sb.append("attacked: " + this.getAttacked() + ", ");
		sb.append("attackedBy: " + this.getAttackedBy() + ", ");
		sb.append("attackedByTimer: " + this.getAttackedByTimer() + ", ");
		sb.append("combat: " + this.getCombat() + ", ");
		sb.append("deathDt: " + this.getDeathDt() + ", ");
		sb.append("killed: " + this.getKilled() + ", ");
		sb.append("killedBy: " + this.getKilledBy() + ", ");
		sb.append("killedDt: " + this.getKilledDt() + ", ");
		sb.append("login: " + this.getLogin());
		if (this.getClass().getSuperclass() != this.getClass()) {
			sb.append("(super.toString=" + super.toString() + ")");
		}
		return sb.toString();		
	}


	/** Equals implementation. 
	 * @see java.lang.Object#equals(java.lang.Object)
	 * @param aThat Object to compare with
	 * @return true/false
	 */
	@Override
	public boolean equals(final Object aThat) {
		Object proxyThat = aThat;
		
		if ( this == aThat ) {
			 return true;
		}

		
		if (aThat instanceof HibernateProxy) {
 			// narrow down the proxy to the class we are dealing with.
 			try {
				proxyThat = ((HibernateProxy) aThat).getHibernateLazyInitializer().getImplementation(); 
			} catch (org.hibernate.ObjectNotFoundException e) {
				return false;
		   	}
		}
		if (aThat == null)  {
			 return false;
		}
		
		final PlayerLasts that; 
		try {
			that = (PlayerLasts) proxyThat;
			if ( !(that.getClassType().equals(this.getClassType()))){
				return false;
			}
		} catch (org.hibernate.ObjectNotFoundException e) {
				return false;
		} catch (ClassCastException e) {
				return false;
		}
		
		
		boolean result = true;
		if (this.getClass().getSuperclass() != this.getClass()) {
			result = super.equals(that);
		}
		result = result && (((this.getId() == null) && ( that.getId() == null)) || (this.getId() != null  && this.getId().equals(that.getId())));
		result = result && (((getAttacked() == null) && (that.getAttacked() == null)) || (getAttacked() != null && getAttacked().equals(that.getAttacked())));
		result = result && (((getAttackedBy() == null) && (that.getAttackedBy() == null)) || (getAttackedBy() != null && getAttackedBy().equals(that.getAttackedBy())));
		result = result && (((getAttackedByTimer() == null) && (that.getAttackedByTimer() == null)) || (getAttackedByTimer() != null && getAttackedByTimer().equals(that.getAttackedByTimer())));
		result = result && (((getCombat() == null) && (that.getCombat() == null)) || (getCombat() != null && getCombat().equals(that.getCombat())));
		result = result && (((getDeathDt() == null) && (that.getDeathDt() == null)) || (getDeathDt() != null && getDeathDt().equals(that.getDeathDt())));
		result = result && (((getKilled() == null) && (that.getKilled() == null)) || (getKilled() != null && getKilled().equals(that.getKilled())));
		result = result && (((getKilledBy() == null) && (that.getKilledBy() == null)) || (getKilledBy() != null && getKilledBy().equals(that.getKilledBy())));
		result = result && (((getKilledDt() == null) && (that.getKilledDt() == null)) || (getKilledDt() != null && getKilledDt().equals(that.getKilledDt())));
		result = result && (((getLogin() == null) && (that.getLogin() == null)) || (getLogin() != null && getLogin().equals(that.getLogin())));
		return result;
	}
	
	

	
}
